Abstraction

It refers to the process of hiding complex implementation details 
and showing only the essential features of an object or system.
    
An abstract class can contain:
    
Abstract methods: Methods without an implementation(just the signature).
These methods must be overrideden in the child class.
    
Abstract class cannot be initiated

Inheritance is required.You must inherit from an abstract class to use it.

_______________________________________________________________________________________

Polymorphism is an object-oriented programming principle that means "many forms." 
It allows you to use a base class variable(Animal) to refer to objects of different derived classes (Dog, Cat, etc.).


"many forms" in polymorphism does refer to the ability of different classes 
to provide different implementations (often through overridden methods) 
for the same method call.

/*public class Animal
{
    public virtual void MakeSound() { }
}

public class Dog : Animal
{
    public override void MakeSound() { Console.WriteLine("Woof!"); }
}

public class Cat : Animal
{
    public override void MakeSound() { Console.WriteLine("Meow!"); }
}

List<Animal> animals = new List<Animal> { new Dog(), new Cat() };
foreach (Animal a in animals)
{
    a.MakeSound(); // Calls the correct MakeSound() for Dog or Cat
}

_______________________________________________________________________________________

In programming, encapsulate (or encapsulation) refers to the concept of bundling data and the methods that operate on that data into a single unit, usually a class. It also means restricting direct access to some of an object's components, which is a fundamental principle in object-oriented programming.

Key Points:

Data (fields) and methods (functions) are combined in a class.
Internal details are hidden from outside access; access is controlled through public methods (getters/setters).
Helps protect the integrity of the data and keeps the implementation details private.
Example in C#:

C#
public class Employee
{
    private string name; // Private field

    public string Name   // Public property
    {
        get { return name; }
        set { name = value; }
    }
}
Here, the name field is encapsulated inside the Employee class. You can only access or modify it using the Name property, not directly.

Benefits:

Data protection (prevents unwanted access/modification)
Easier maintenance
Improved code organization and readability

_______________________________________________________________________________________

Upcasting to access overriden methods in child class and base class methods.
downcasting to access child class methods.



class Animal
{
    public virtual void Speak() { Console.WriteLine("Animal speaks"); }
}

class Dog : Animal
{
    public override void Speak() { Console.WriteLine("Dog barks"); }
    public void WagTail() { Console.WriteLine("Dog wags tail"); }
}

 ---Upcasting (Safe & Implicit)---

Dog dog = new Dog();
Animal animal = dog; // Upcasting (We use this to use overridden methods in the child class)
animal.Speak();      // Calls Dog’s Speak() due to polymorphism
animal.WagTail(); ❌ Not allowed, as WagTail is not in Animal class

________________________________________________________________________________________

---Downcasting (Explicit & Risky)---

Animal animal = new Dog();   // Upcast
Dog dog = (Dog)animal;       // Downcast
dog.WagTail();               // OK

DANGER: If the object isn't actually a Dog, it throws InvalidCastException:


Animal a = new Animal();
Dog d = (Dog)a; // ❌ Runtime crash!

___________________________________________________________________________________________
Safe Downcasting
Option 1: Using is pattern

if (animal is Dog dog)
{
    dog.WagTail();
}
Option 2: Using as

Dog dog = animal as Dog;
if (dog != null)
{
    dog.WagTail();
}